# Clase 9: 07 de octubre de 2024

En esta clase hicimos un ejercicio avanzando y despu√©s se resolvi√≥ ejercicios de parciales de otros a√±os

# EC0: Es primo
*Averiguar si un n√∫mero dado es primo. Un n√∫mero es primo si solo tiene como divisores al 1 y el mismo.*

En este caso la idea es generar todos los n√∫meros entre 1 y el n√∫mero (inclu√≠do) y comprobar cu√°ntos son divisores del n√∫mero. Si hay m√°s de 2 divisores, no ser√° primo. 

Soluci√≥n con contador:

```python
# Leer un n√∫mero
n: int = int(input("Dime un n√∫mero: "))

num_divisores: int = 0
# Generar todos los n√∫mero de 1 a n
for num in range(1, n+1):        
    # Comprobar si es divisor y contarlo
    if n%num == 0:
        num_divisores += 1
    
# Si tiene 1 o 2 divisores es primo
if num_divisores <= 2:
    print(n, "es primo")
else:
    print(n, "no es primo")
```

Otra soluci√≥n es mirar que no haya ning√∫n divisor entre 2 y n-1 (Soluci√≥n con centinelas - bool):

```python
n: int = int(input("Dime un n√∫mero: "))

es_primo: bool = True
for i in range(2, n):
  if n%i == 0:
    es_primo = False
    
if es_primo:
  print(n, "es primo")
else:
  print(n, "no es primo")
```

Finalmente se puede plantear una soluci√≥n m√°s eficiente que pare cuando encuentre el primer divisor (>1). Si lo encuentra antes de llegar al n√∫mero es que no es primo (tiene otro divisor):

```python
n: int = int(input("Dime un n√∫mero: "))
potencial_divisor: int = 2

while n%potencial_divisor != 0:
  potencial_divisor += 1
    
if potencial_divisor == n:
  print(n, "es primo")
else:
  print(n, "no es primo")
```

# EC1: Primer y √∫ltimo 12:

*Escribe un algoritmo que lea una lista de n√∫meros enteros terminada en 0 y que encuentre y escriba en la pantalla al posici√≥n de la primera y √∫ltima ocurrencia del n√∫mero 12 dentro de la lista. Si el n√∫mero 12 no est√° en la lista, el algoritmo debe escribir 0.*

Esto es un ejemplo de ejercicio avanzado que, salvo que se tenga experiencia, hay que ir resolviendo poco a poco:
* Primero leer hasta 0 (esto es un caso tradicional de lectura adelantada)
* Luego tenemos que ir contando las posiciones de los n√∫meros que leemos:
  * En la primera lectura (la adelantada al bucle) indicamos que es la primera
  * Luego cada vez que leamos en el bucle decimos que hemos le√≠do una mas.
* El siguiente punto es c√≥mo saber la posici√≥n del √∫ltimo:
  * En el enunciado nos indica que si no existe ning√∫n 12 devolvamos un 12, entonces se puede inicializar a 0
  * Luego cada vez que leamos un 12 debemos actualizarlo ya que ese doce le√≠do es posterior a cualquiera que hayamos le√≠do antes
* El √∫ltimo punto es c√≥mo saber la primera posici√≥n:
  * Aqu√≠ el problema es distinguir si un 12 es el primero o no.
  * Si inicializamos el primero a 0 (por el mismo motivo que el √∫ltimo), eso ayuda a identificar el primero, ya que si la posici√≥n del primero es 0 (que es una posici√≥n incorrecta) quiere decir que a√∫n no hemos le√≠so ning√∫n doce y podemos actualizarlo. Luego ya la posici√≥n ser√° diferente de 0 y no se actualizar√° m√°s. Tambi√©n se puede contar cuantos 12 se han encontrado y solo cambiar el valor si es el primer 12 o poner un centinela para saber si se ha le√≠do el 12 antes o no.

```python
num: int = int(input("Dime un n√∫mero: "))
pos: int = 1
primero: int = 0
cantidad_12_leidos: int = 0
he_leido_un_12: bool = False
while num != 0:
    # Hacer cosas con num
    if num == 12:
        cantidad_12_leidos += 1
        ultimo = pos
        #if primero == 0:
        #if cantidad_12_leidos == 1:
        if not he_leido_un_12:
            primero = pos
            he_leido_un_12 = True
    
    num = int(input("Dime otro n√∫mero: "))
    pos += 1
    
if cantidad_12_leidos == 0:
    print("No hab√≠a 12s")
else:
    print("El primero fue en", primero, "y el √∫ltimo en", ultimo)
```

## EC2 (Ej 1 de Parcial 2021/2022 B)
*Hacer un programa que pide n√∫meros enteros hasta el 0. El programa despu√©s debe indicar si todos los n√∫meros estaban en orden, por ejemplo -3 5 5 9 0 dir√≠a True, con 0 tambi√©n dir√≠a True pero con 8 7 0 dir√≠a False.*

```python
n√∫mero: int = int(input("Dime un n√∫mero: ")) # Lectura previa al bucle

anterior: int = n√∫mero - 1 # Cualquier valor <= n√∫mero vale
esta_ordenado: bool = True
while n√∫mero != 0:
  # Hacer cosas con el n√∫mero
  if n√∫mero < anterior:
    esta_ordenado = False
  anterior = n√∫mero
  n√∫mero: int = int(input("Dime otro n√∫mero: "))
    
if esta_ordenado:
  print("Est√° ordenado")
else:
  print("No est√° ordenado")
```

## EC4 (Parcial 2021/2022):
*Realice un programa que lea un n√∫mero positivo, n, y nos indique si el n√∫mero es perfecto (la suma de sus divisores propios ‚Äìsin considerarse el mismo- da su propio valor). Por ejemplo 6 es perfecto (6 = 1 + 2 + 3)*

```python
n: int = int(input("Dime un n√∫mero: "))

suma: int = 0
# Generar n√∫mero entre 1 y n (sin el n)
for num in range(1, n):
    if n % num == 0:
        suma += num

if n == suma:
    print(n, "es perfecto")
else:
    print(n, "no es perfecto")
```

## EC6 (Parcial 2020/2021):
*Dada una secuencia de ADN (l√≠nea de texto con muchos amino√°cidos: A, T, C, G), nos indique cu√°ntas hay que cada tipo*

```python
cadena_adn: str = input("Dime la secuencia de ADN: ")

contador_A: int = 0
contador_T: int = 0
contador_C: int = 0
contador_G: int = 0
for letra in cadena_adn:
    if letra == 'A':
        contador_A += 1
    elif letra == 'T':
        contador_T += 1
    elif letra == 'C':
        contador_C += 1
    else:
        contador_G += 1

print("N√∫mero de A:", contador_A)
print("N√∫mero de T:", contador_T)
print("N√∫mero de C:", contador_C)
print("N√∫mero de G:", contador_G)
```

## EC7 (Parcial 2023/2024):
*La secuencia de Collatz se establece de la siguiente forma:*

* *ùê∂ùëúùëôùëôùëéùë°ùëß(ùë° + 1) = ùê∂ùëúùëôùëôùëéùë°ùëß(ùë°)/2 ùë†ùëñ ùê∂ùëúùëôùëôùëéùë°ùëß(ùë°) ùëíùë† ùëùùëéùëü*
* ùê∂ùëúùëôùëôùëéùë°ùëß(ùë° + 1) = 3 ‚àó ùê∂ùëúùëôùëôùëéùë°ùëß(ùë°) + 1 ùëíùëõ ùëúùë°ùëüùëú ùëêùëéùë†ùëú*

*Existe una conjetura que indica que, para cualquier valor inicial, siempre se alcanza el 1. Por ejemplo, si usamos el 3 como valor inicial se tardan 7 pasos en alcanzar el valor 1: Collatz(0) = 3, Collatz(1) = 10, Collatz(2) = 5, Collatz(3) = 16, Collatz(4) = 8, Collatz(5) = 4, Collatz(6) = 2, Collatz(7) = 1. Realiza un programa que lea el valor inicial y nos indique cu√°ntos pasos son necesarios para alcanzar el 1. Note que, si el valor inicial ya es 1, devolver√° 0 pasos.*

```python
secuencia: int = int(input("Dime el valor inicial de la secuencia: "))
paso: int = 0

while secuencia != 1:
    # Calcular el siguiente
    if secuencia % 2 == 0:
        secuencia = secuencia / 2
    else:
        secuencia = 3*secuencia + 1
    paso += 1
    
print("He tardado", paso, "pasos en llegar a 1")
```
